theory ABE_final
/*
roles:
trusted_authority - generates keys, and atributes
sender - encrypt messages and send to reciever using common channel
reciever - recieves private key, encrypted message and decrypt it.


One public key corresponds to two private keys.

it does not differ from  multiple aenc...
*/

begin

functions: pkk/1, enc/5, dec/3, skk/4
equations: 
   ///////////////////////////////////
   // policy 1: a1 or (a2 and a3)
   // a1
   dec(pkk(msk),enc(pkk(msk), m, a1, a2, a3),skk(msk, a1, x1, x2)) = m, 

   //  a2 and a3 
   dec(pkk(msk),enc(pkk(msk), m, a1, a2, a3),skk(msk, x, a2, a3)) = m,

   ///////////////////////////////////
   // policy 2: a1 or a2
   // ltk1 --> the same as in policy 1, we provide second equations to show that it is another policy but it is not necessary.
   dec(pkk(msk),enc(pkk(msk), m, a1, a2, a3),skk(msk, a1, x1, x2)) = m,
   
   // ltk2
   dec(pkk(msk),enc(pkk(msk), m, a1, a2, a3),skk(msk, x1, a2, x3)) = m,

rule key_gen:
let
  PK = pkk(~msk)
  SK_a1 = skk(~msk,'a1','x2','x3')
  SK_a2 = skk(~msk,'x1','a2','x3') 
  SK_a3 = skk(~msk,'x1','x2','a3')

  SK_a12 = skk(~msk,'a1','a2','x3')
  SK_a13 = skk(~msk,'a1','x2','a3')
  SK_a23 = skk(~msk,'x1','a2','a3')

  SK_a123 = skk(~msk,'a1','a2','a3')
in
  [Fr(~msk)]
--[P1($A1, SK_a1) 
  ,P2($A2, SK_a2) 
  ,P2($A3, SK_a3)
  ,P12($A12, SK_a12)
  ,P13($A13, SK_a13)
  ,P23($A23, SK_a23)
  ,P123($A123, SK_a123)
  ,OnlyOnce()
  ]->
  [!Party($A1, SK_a1) 
  ,!Party($A2, SK_a2)
  ,!Party($A3, SK_a3)
  ,!Party($A12, SK_a12)
  ,!Party($A13, SK_a13)
  ,!Party($A23, SK_a23)
  ,!Party($A123, SK_a123)
  ,!PK(PK)
  ,MSK(~msk)
  ,Out(PK)
  ]

rule enc:
let
    c = enc(PK, ~m, 'a1', 'a2', 'a3')
in  
  [!PK(PK), Fr(~m)]--[Enc(~m)]->[Out(c)]

rule dec: 
let
    m = dec(PK,c,SK)
in
    [In(c), !Party(A, SK), !PK(PK)]
    --[Dec(m,A)]->[]


rule Reveal_msk:
[MSK(msk)]--[Reveal_all(), Revealed_msk()]->[Out(msk)]

rule Reveal_SK:
[!Party(A, SK)]--[Reveal_all(), Revealed_SK(A,SK)]->[Out(SK)]

lemma P1_all_dec_ex:
    exists-trace    
    "Ex m P1 P12 P13 P23 P123 SK1 SK12 SK13 SK23 SK123 #i #e #j1 #j12 #j13 #j23 #j123
    .P1(P1,SK1)@i & P12(P12,SK12)@i & P13(P13,SK13)@i & P23(P23,SK23)@i & P123(P123,SK123)@i
    &Enc(m)@e
    &Dec(m,P1)@j1
    &Dec(m,P12)@j12
    &Dec(m,P13)@j13
    &Dec(m,P23)@j23
    &Dec(m,P123)@j123 
    "

lemma P2_all_dec_ex:
    exists-trace    
    "Ex m P1 P2 P12 P13 P23 P123 SK1 SK2 SK12 SK13 SK23 SK123 #i #e #j1 #j2 #j12 #j13 #j23 #j123
    .P1(P1,SK1)@i &P2(P2,SK2)@i & P12(P12,SK12)@i & P13(P13,SK13)@i & P23(P23,SK23)@i & P123(P123,SK123)@i
    &Enc(m)@e
    &Dec(m,P1)@j1
    &Dec(m,P2)@j2
    &Dec(m,P12)@j12
    &Dec(m,P13)@j13
    &Dec(m,P23)@j23
    &Dec(m,P123)@j123 
    "

lemma secrecy:
    "All m  #i. 
     Enc(m)@i
    &not (Ex #k. Reveal_all()@k)
    ==> not (Ex #k. K(m)@k)"

restriction TA_onlyOnce:
    "All #i #j. OnlyOnce()@i & OnlyOnce()@j ==> #i = #j"
end

