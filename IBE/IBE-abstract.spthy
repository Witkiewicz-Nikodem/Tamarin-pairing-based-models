theory IBE_abstract
begin

functions: pkk/1,
           skk/2, 
           encrypt/4, 
           decrypt/2 

equations: decrypt(encrypt(m, ID, pkk(msk),r),skk(ID,msk)) = m

/* Set Up */
rule Setup:
let 
    pk_PKG = pkk(~Ltk_PKG)
in
    [ Fr(~Ltk_PKG) ]
  --[Register_PKG($PKG)]->
    [!PKG_Ltk($PKG, ~Ltk_PKG), !Pk_PKG($PKG, pk_PKG), Out(pk_PKG)]

/* Extract */
rule Extract:
let
    ltk = skk($B,Ltk_PKG)
in
[!PKG_Ltk(PKG, Ltk_PKG)]
--[Extract($B,ltk)]->
[!LTK($B,ltk), !Pk($B)]

rule Encrypt:
let 
    c = encrypt(~m,B,pk_PKG,~r)
in
    [Fr(~m), !Pk(B), !Pk_PKG(PKG, pk_PKG), Fr(~r)]
    --[Enc(B, ~m)]->
    [Out(c)]

rule Decrypt:
let 
    m = decrypt(c,ltk)
in
    [!LTK(B,ltk), In(c)]
    --[Dec(B,m)]->
    []

rule Reveal_receiver:
    [!LTK(B,ltk)]
    --[Receiver_revealed(B)]->
    [Out(ltk)]

rule Reveal_master:
    [!PKG_Ltk(PKG, Ltk_PKG)]
    --[Master_revealed(PKG)]->
    [Out(Ltk_PKG)]

lemma proper_execution:
    exists-trace
    "Ex B m #i #j.
     Enc(B,m)@i &
     Dec(B,m)@j"

lemma message_secrecy:
    "All B msent #i.
     Enc(B,msent)@i 
    & not (Ex #k. Receiver_revealed(B)@k)
    & not (Ex PKG #k. Master_revealed(PKG)@k)
        ==> not (Ex #j. K(msent)@j)"
             
lemma receiver_ltk_revealed:
/*If receiver key is compromised then adversary is able to decrypt messages*/
    exists-trace
    "Ex B m #i #j. Dec(B,m)@i 
     & Enc(B,m)@j
     & not ( Ex PKG #l. Master_revealed(PKG)@l)
     & (Ex #m. K(m)@m)"

lemma master_ltk_revealed:
/*If master key is compromised then adversary is able to decrypt message */
    exists-trace
    "Ex B m #i #j. Dec(B,m)@i 
     & Enc(B,m)@j
     & not ( Ex B #l. Receiver_revealed(B)@l)
     & (Ex #n. K(m)@n)"
end